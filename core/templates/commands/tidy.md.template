---
description: Commit changes, sync beads, and push to remote
@IF_CLAUDECODE@
allowed-tools: Bash, Read, Write, Edit, Glob, Grep, TodoWrite
@ENDIF_CLAUDECODE@
---

@IF_KIRO@
**You are now executing this workflow.** Begin immediately with Step 1. Do not summarize, describe, or explain what you will do — just do it. If the user included any text in their message, that text is the input argument — use it directly, do not ask for it again.
@ENDIF_KIRO@

## Summary

**File discovered issues, commit changes, and push to remote.** Part of prep → cook → serve → tidy.

This is where findings from `/@NAMESPACE@cook` and `/@NAMESPACE@serve` get filed as beads.

---

## Finding Filing Strategy

Findings from cook and serve are filed as **siblings under the current task's parent feature**:

**Code/project findings (any priority)** → sibling tasks under parent feature
**Process improvement suggestions** → Retrospective epic

This ensures:
- Findings are addressed before the feature is plated (all children must close)
- The loop picks them up next (highest priority first)
- Context is maintained (findings cluster with related work)

**Edge cases:**
- Task parent is an **epic** (no feature layer) → file under the epic
- Task has **no parent** → file as standalone with appropriate priority

### Bead Creation Reference

@IF_CLAUDECODE@
**Always include a description** with discovery context:

```bash
# Code/project findings → sibling under parent feature
bd create --title="..." --type=task|bug --priority=0-4 \
  --parent=<parent-feature-or-epic> \
  --description="$(cat <<'EOF'
Discovery Source: <source-task-id> - <source-task-title>
Discovered During: <cook|serve> phase

Impact:
<why this matters - user impact, technical debt, or risk>

Context:
<before/after state if relevant, file/component involved>
EOF
)"

# Priority: 0=critical, 1=high, 2=medium, 3=low, 4=backlog
# Types: task, bug (broken), feature (new capability)

# Process improvement suggestions → Retrospective epic
# (Ways to improve cook, serve, tidy, plate, or other workflow phases)
bd create --title="..." --type=task --priority=4 --parent=<retrospective-epic> \
  --description="$(cat <<'EOF'
Discovery Source: <source-task-id> - <source-task-title>
Discovered During: <cook|serve> phase

Suggestion:
<how the workflow phase could be improved>

Context:
<observation that triggered this suggestion>
EOF
)"
```
@ENDIF_CLAUDECODE@
@IF_OPENCODE@
```bash
# Code/project findings → sibling under parent feature
bd create --title="..." --type=task|bug --priority=0-4 --parent=<parent-feature-or-epic>

# Priority: 0=critical, 1=high, 2=medium, 3=low, 4=backlog
# Types: task, bug (broken), feature (new capability)

# Process improvement suggestions → Retrospective epic
# (Ways to improve cook, serve, tidy, plate, or other workflow phases)
bd create --title="..." --type=task --priority=4 --parent=<retrospective-epic>
```
@ENDIF_OPENCODE@

**Retrospective epic:**

Reserved for **process improvement suggestions** (not code findings):
- Workflow phase improvements (cook, serve, tidy, etc.)
- Tooling or automation suggestions
- Process observations

```bash
# One-time setup (if not exists)
bd create --title="Retrospective" --type=epic --priority=4

# File process improvements as children
bd create --title="Consider adding lint step to serve" --type=task --priority=4 --parent=<retro-epic-id>
```

## Process

### Step 1: Collect Tidy State

Gather filing parent, in-progress tasks, epic eligibility, and git status in one pass:

```bash
TASK_ID="<current-task-id>"

echo "=== PARENT ==="
bd show $TASK_ID --json 2>/dev/null | jq -r '.[0].parent // empty' || echo "(none)"
echo "=== IN PROGRESS ==="
bd list --status=in_progress 2>/dev/null || echo "(none)"
echo "=== EPIC ELIGIBLE ==="
bd epic close-eligible --dry-run 2>/dev/null || echo "(none)"
echo "=== GIT STATUS ==="
git status --porcelain
```

Use the PARENT value from output as `--parent` for all code/project findings. If no parent exists, file as standalone beads.

### Step 2: File Discovered Issues

Review findings from `/@NAMESPACE@cook` and `/@NAMESPACE@serve` and create beads with full context.

@IF_CLAUDECODE@
**Code/project findings** (file as siblings under parent feature/epic):
```bash
bd create --title="Fix race condition in session cleanup" \
  --type=bug --priority=2 \
  --parent=$PARENT \
  --description="$(cat <<'EOF'
Discovery Source: lc-abc - Implement session timeout
Discovered During: cook phase

Impact:
Sessions may not be cleaned up under load, causing resource leaks.
This affects production reliability under concurrent requests.

Context:
Test for timeout cleanup failed intermittently.
Related: internal/session/manager.go:145
EOF
)"
```

**Lower-priority code findings** (still under parent, not retro):
```bash
bd create --title="Consider caching session lookups" \
  --type=task --priority=4 \
  --parent=$PARENT \
  --description="$(cat <<'EOF'
Discovery Source: lc-abc - Implement session timeout
Discovered During: cook phase (profiling)

Impact:
Performance optimization opportunity, not blocking.
Could reduce latency by ~20ms per request in hot path.

Context:
Session.Get() called 10+ times per request in hot path.
Related: internal/session/store.go
EOF
)"
```

**Process improvement suggestions** (file under Retrospective epic):
```bash
bd create --title="Consider adding lint step to serve phase" \
  --type=task --priority=4 --parent=<retro-epic> \
  --description="$(cat <<'EOF'
Discovery Source: lc-abc - Implement session timeout
Discovered During: serve phase

Suggestion:
Serve could run a linter before sous-chef review to catch style issues automatically.

Context:
Sous-chef spent review time on formatting issues that a linter would catch.
EOF
)"
```
@ENDIF_CLAUDECODE@
@IF_OPENCODE@
**Code/project findings** (file as siblings under parent feature/epic):
```bash
bd create --title="<issue>" --type=bug|task --priority=1-3 --parent=$PARENT
```

**Lower-priority code findings** (still under parent, not retro):
```bash
bd create --title="<suggestion>" --type=task --priority=4 --parent=$PARENT
```

**Process improvement suggestions** (file under Retrospective epic):
```bash
bd create --title="<workflow suggestion>" --type=task --priority=4 --parent=<retro-epic>
```
@ENDIF_OPENCODE@

#### Research Findings (for research tasks)

When the task involved research (architecture analysis, spike, investigation), also capture findings:

**New beads for discoveries** (file under parent feature/epic):
```bash
bd create --title="Implement <finding>" --type=task --priority=2-3 --parent=$PARENT
bd create --title="Document <pattern>" --type=task --priority=3 --parent=$PARENT
```

**Update existing beads:**
```bash
bd comments add <id> "RESEARCH FINDINGS:
- <key insight 1>
- <key insight 2>
- Recommendation: <action>"
```

**Research output patterns:**
- Actionable improvement → Create task bead
- Architectural insight → Comment on epic or create doc task
- Blocker discovered → Create bug/task as dependency
- Option evaluated → Comment on research task
- Decision made → Update task description

@IF_CLAUDECODE@
### Step 3: Review In-Progress Issues
@ENDIF_CLAUDECODE@
@IF_OPENCODE@
### Step 3: Review In-Progress Issues
@ENDIF_OPENCODE@

Using the IN PROGRESS list from Step 1, review each in-progress issue:
- If task appears complete based on git changes → `bd close <id>`
- If task is incomplete → leave as-is (will be picked up next session)
- If status is unclear → create a P4 bead to review later

**Do NOT ask the user** - make a reasonable judgment or file a bead.

@IF_CLAUDECODE@
### Step 4: Check for Epic Closures and Branch Merges
@ENDIF_CLAUDECODE@
@IF_OPENCODE@
### Step 4: Check for Epic Closures
@ENDIF_OPENCODE@

Using the EPIC ELIGIBLE list from Step 1, check if any epics are now eligible for closure (all children complete).

If epics are eligible:
1. Close them: `bd epic close-eligible`
@IF_CLAUDECODE@
2. For each closed epic, **merge the epic branch to main**:
   ```bash
   for EPIC_ID in $(bd epic close-eligible --dry-run --json 2>/dev/null | jq -r '.[].id' || true); do
     EPIC_BRANCH="epic/$EPIC_ID"
     CURRENT=$(git branch --show-current)

     if [ "$CURRENT" = "$EPIC_BRANCH" ]; then
       EPIC_TITLE=$(bd show $EPIC_ID --json | jq -r '.[0].title')

       # Checkout main and merge
       git checkout main
       git pull --rebase

       if git merge --no-ff $EPIC_BRANCH -m "Merge epic $EPIC_ID: $EPIC_TITLE"; then
         # Success - delete branch and push
         git branch -d $EPIC_BRANCH
         git push origin main
         git push origin --delete $EPIC_BRANCH 2>/dev/null || true
       else
         # Merge conflict - abort and create bug bead
         git merge --abort
         git checkout $EPIC_BRANCH

         bd create --title="Resolve merge conflict for epic $EPIC_ID" \
           --type=bug --priority=1 \
           --description="Epic $EPIC_ID ($EPIC_TITLE) completed but merge to main failed due to conflicts."

         echo "⚠️ MERGE CONFLICT - manual resolution required"
       fi
     fi
   done
   ```

3. Get children for the summary:
@ENDIF_CLAUDECODE@
@IF_OPENCODE@
2. For each closed epic, get its children for the summary:
@ENDIF_OPENCODE@
   ```bash
   bd list --parent=<epic-id> --all --json
   ```

@IF_CLAUDECODE@
**Note:** Epic closures are significant milestones and are highlighted in the session summary.
@ENDIF_CLAUDECODE@
@IF_OPENCODE@
**Note:** Epic closures are significant milestones. They will be highlighted prominently in the session summary.

> **Epic Philosophy:** Epics use children (`--parent`) for grouping, not blocking dependencies.
> Dependencies between children establish order within an epic.
> See AGENTS.md for the full epic philosophy.
@ENDIF_OPENCODE@

@IF_CLAUDECODE@
### Step 5: Commit Changes with Kitchen Log
@ENDIF_CLAUDECODE@
@IF_OPENCODE@
### Step 5: Commit Changes with Kitchen Log
@ENDIF_OPENCODE@

Using the GIT STATUS output from Step 1, check for pending changes.

If changes exist:
1. Stage all relevant files: `git add -A`
2. Create a commit with the kitchen log format

**Kitchen log commit format:**
```bash
git commit -m "<task-id>: <Short objective>

<Detailed description of changes>

Implementation includes:
- Key feature 1
- Key feature 2
- Error handling approach

Deliverable: <What was created>
Tests: <Test summary>
Signal: KITCHEN_COMPLETE

Review findings:
- Sous-chef assessment: <verdict>
- Test quality assessment: <result>
- Issues addressed: <count>"
```

**Commit message structure:**
- Subject: `<task-id>: <Short objective>` (50 chars, imperative mood)
- Blank line
- Body: What and why (wrap at 72 chars)
- Implementation details (bullet points)
- Deliverable and test info
- Review and test quality feedback
- Signal emitted

@IF_CLAUDECODE@
### Step 6: Verify Closing Kitchen
@ENDIF_CLAUDECODE@
@IF_OPENCODE@
### Step 6: Verify Closing Kitchen
@ENDIF_OPENCODE@

Before pushing, verify all quality gates pass:

**Kitchen closing checklist:**
- [ ] All issues filed correctly
- [ ] Commit message follows kitchen log format
- [ ] Changes staged and committed
- [ ] Beads synced with `bd sync`
- [ ] Ready to push to remote

**If any checklist item fails:**
- Create P2 bead for follow-up
- Note in commit body
- Continue with push if non-blocking issue

@IF_CLAUDECODE@
### Step 7: Sync and Push
@ENDIF_CLAUDECODE@
@IF_OPENCODE@
### Step 7: Sync and Push
@ENDIF_OPENCODE@

```bash
bd sync                        # Commit beads changes
git pull --rebase && git push  # Push to remote (if remote exists)
```

If no remote is configured, skip the push step.

If push fails:
```bash
bd create --title="Resolve git push failure: <error>" --type=bug --priority=2
```

**CRITICAL:** Work is NOT complete until `git push` succeeds. If push fails, resolve and retry.

@IF_CLAUDECODE@
### Step 8: Record Session Summary
@ENDIF_CLAUDECODE@
@IF_OPENCODE@
### Step 8: Record Session Summary
@ENDIF_OPENCODE@

**Add final comment to the task:**
```bash
bd comments add <id> "PHASE: TIDY
Status: completed

SESSION SUMMARY
━━━━━━━━━━━━━━━
Intent: <why this change was made>
Before: <previous state/capability>
After: <new state/capability>

Problems encountered:
  - <problem>: <how resolved>

Issues filed:
  - <new-id>: <title> [P<n>]

Commit: <hash>
Push: <success|failed>"
```

@IF_CLAUDECODE@
### Step 9: Output Kitchen Report
@ENDIF_CLAUDECODE@
@IF_OPENCODE@
### Step 9: Output Kitchen Report
@ENDIF_OPENCODE@

**If an epic was closed**, output the epic completion banner first:

```
════════════════════════════════════════════
  EPIC COMPLETE: <epic-id> - <epic-title>
@IF_CLAUDECODE@
  Branch: epic/<epic-id> merged to main
@ENDIF_CLAUDECODE@
════════════════════════════════════════════

Children completed (<count>):
  ✓ <id>: <title>
  ✓ <id>: <title>
  ✓ <id>: <title>
  ...

Impact:
  <1-2 sentence description of what capability/improvement is now complete,
   derived from the epic description>

════════════════════════════════════════════
```

@IF_CLAUDECODE@
**If merge failed (conflict):**

```
════════════════════════════════════════════
  EPIC COMPLETE: <epic-id> - <epic-title>
════════════════════════════════════════════

⚠️ MERGE CONFLICT
Epic branch could not be merged to main.

Conflicts require manual resolution:
  1. Resolve conflicts manually
  2. git add <resolved-files>
  3. git commit
  4. git push origin main
  5. git branch -d epic/<epic-id>

Bug bead created: <new-bead-id>

════════════════════════════════════════════
```

@ENDIF_CLAUDECODE@
**Then output the kitchen report:**

```
╔══════════════════════════════════════════════════════════════╗
║  TIDY: Kitchen Closed                                        ║
╚══════════════════════════════════════════════════════════════╝

SESSION SUMMARY
━━━━━━━━━━━━━━━

Task: <id> - <title>

INTENT:
  <1-2 sentences from task description>
  Goal: <deliverable or acceptance criteria>

BEFORE → AFTER:
  <previous state> → <new state>
  <what couldn't be done> → <what can be done now>

Files changed:
  M src/foo.ts (+45, -12)
  A src/bar.ts (+78)

Problems encountered:
  - <problem description>
    Resolution: <how it was resolved>
  - (none)

Issues closed: <count>
  ✓ <id>: <title>

Epics completed: <count>
  ★ <epic-id>: <title> (<N> children)

Issues filed: <count>
  Under parent (<parent-id>):
    + <new-id>: <title> [P<n>]
@IF_CLAUDECODE@
      Source: <source-task-id> (<cook|serve> phase)
@ENDIF_CLAUDECODE@
  Under Retrospective:
    + <new-id>: <title> [P4/retro]
@IF_CLAUDECODE@
      Source: <source-task-id> (<cook|serve> phase)
@ENDIF_CLAUDECODE@

Commit: <hash>
  <commit message>

Push: ✓ origin/main | ⚠️ <error> | skipped (no remote)

Session complete.

@IF_CLAUDECODE@
───────────────────────────────────────────
NEXT STEPS
───────────────────────────────────────────
Ready tasks remaining: <count>

  /clear       Clear context before next cycle (recommended)
  /@NAMESPACE@prep   Start fresh cycle
  /@NAMESPACE@run    Continue automatically
  /@NAMESPACE@help   See all commands

Tip: Clear context between tasks to prevent accumulation.

<phase_complete>DONE</phase_complete>
@ENDIF_CLAUDECODE@
```

@IF_CLAUDECODE@
**Phase completion signal:** The `<phase_complete>DONE</phase_complete>` tag signals to the line-loop orchestrator that this phase has completed its work and can be terminated early. Always emit this signal at the very end of successful completion output.

@ENDIF_CLAUDECODE@
**Information sources for summary:**
- **Intent**: Extract from task description via `bd show <id>`
- **Before**: Derive from git diff context - what existed before (files modified, previous behavior)
- **After**: Semantic summary from cook completion - what capability exists now

## Design Rationale

@IF_CLAUDECODE@
This command is intentionally **non-interactive**:
@ENDIF_CLAUDECODE@
@IF_OPENCODE@
This command is intentionally **non-interactive** to support:
@ENDIF_OPENCODE@

1. **Workflow velocity** - No blocking on user input
2. **Deferred decisions** - Unclear items become beads, not blockers
3. **Session end discipline** - Quick cleanup without decision fatigue
4. **Information when needed** - Bead creation reference provided where it's used

@IF_CLAUDECODE@
"File, don't block" — concerns requiring user judgment are captured as beads for later triage.
@ENDIF_CLAUDECODE@
@IF_OPENCODE@
The pattern "file, don't block" means any concern that would require user judgment gets captured as a bead for later triage rather than interrupting the current flow.
@ENDIF_OPENCODE@

## Example Usage

```
/@NAMESPACE@tidy
```

This command takes no arguments.
