{"id":"demo-001","title":"Line Cook Dashboard MVP","issue_type":"epic","status":"open","priority":2,"labels":["mvp","demo","go"],"description":"Build a Go web dashboard for monitoring Line Cook workflows in real time.\n\n## Goals\n- Display real-time loop status and iteration history\n- Receive and display hook events from Claude Code\n- Live updates via WebSocket/SSE\n\n## Success Criteria\n- Dashboard shows current loop status (running/stopped, iteration count, phase)\n- Iteration history timeline with verdict badges and commit links\n- Hook event feed with type filtering\n- Live updates without manual refresh\n\n## Stack\n- Go 1.25+, Templ, SQLite (WAL mode)\n- HTMX + Tailwind CSS (CDN)\n- Gorilla WebSocket\n\n## Out of Scope for MVP\n- Authentication\n- Multi-project support\n- Metrics charts and performance graphs (parking lot)\n\nPlanning context: docs/planning/context-demo-web/"}
{"id":"demo-001.1","title":"Real-time loop status display","issue_type":"feature","status":"open","priority":2,"parent":"demo-001","labels":["core-feature"],"description":"Display current loop status on a web dashboard.\n\n## User Stories\n- As a developer, I can see the current loop status so I know if the loop is running or stopped\n- As a developer, I can see the current iteration, phase, and task so I can monitor progress\n\n## Acceptance Criteria\n- [ ] HTTP server starts on configurable port with health/ready endpoints\n- [ ] SQLite database stores events and loop status\n- [ ] Dashboard page shows current loop status (running/stopped, iteration count, current phase, current task, last update)\n- [ ] Status updates when loop state changes\n\n## Technical Notes\n- Go net/http standard library (no frameworks)\n- Templ for HTML generation\n- SQLite with WAL mode for concurrent reads"}
{"id":"demo-001.1.1","title":"Go HTTP server with health endpoint","issue_type":"task","status":"open","priority":2,"parent":"demo-001.1","labels":["foundation","ready"],"description":"Create the Go HTTP server foundation with health and readiness endpoints.\n\n## Requirements\n- cmd/server/main.go: HTTP server on configurable port (default 4000)\n- GET /health returns {\"status\":\"ok\"} with 200\n- GET /ready returns {\"ready\":true} with 200\n- Graceful shutdown on SIGINT/SIGTERM (30s timeout)\n- internal/config/config.go: read PORT, DB_PATH, LOOP_DATA_DIR from env with defaults\n- go.mod initialized (module: line-cook-dashboard)\n\n## Implementation Notes\n- Use net/http standard library (no frameworks)\n- Config via os.Getenv with sensible defaults\n- Context-based shutdown with signal.NotifyContext\n- Reference: ~/code/observability/cmd/server/main.go\n\n## Test Specifications\n- TestHealthEndpoint_Returns200\n- TestReadyEndpoint_Returns200\n- TestConfigDefaults\n- TestConfigFromEnv\n\n## Manual Verification\n- go build -o server ./cmd/server && ./server\n- curl localhost:4000/health → {\"status\":\"ok\"}\n- curl localhost:4000/ready → {\"ready\":true}"}
{"id":"demo-001.1.2","title":"SQLite schema and event storage","issue_type":"task","status":"open","priority":2,"parent":"demo-001.1","depends_on":["demo-001.1.1"],"labels":["database","blocked"],"description":"Set up SQLite database with schema and query functions for events and loop status.\n\n## Requirements\n- internal/db/db.go: Open SQLite with WAL mode, run auto-migrations\n- events table: id, source, event_type, payload (JSON), timestamp\n- loop_status table: key-value for latest loop state\n- internal/db/queries.go: InsertEvent, GetRecentEvents, UpsertLoopStatus\n- internal/models/models.go: HookEvent, LoopStatus structs\n\n## Implementation Notes\n- Use modernc.org/sqlite (pure Go, no CGO)\n- Migrations run on Open(), idempotent CREATE TABLE IF NOT EXISTS\n- WAL mode set via PRAGMA on connection open\n- Reference: ~/code/observability/internal/db/\n\n## Test Specifications\n- TestOpenDB_CreatesTables\n- TestInsertEvent_StoresAndRetrieves\n- TestGetRecentEvents_ReturnsInOrder\n- TestUpsertLoopStatus\n\n## Manual Verification\n- go test ./internal/db/... -v\n- Inspect dashboard.db with sqlite3 CLI after running tests"}
{"id":"demo-001.1.3","title":"Dashboard page showing loop status","issue_type":"task","status":"open","priority":2,"parent":"demo-001.1","depends_on":["demo-001.1.2"],"labels":["frontend","blocked"],"description":"Render the main dashboard page showing current loop status.\n\n## Requirements\n- GET / renders dashboard with current loop status\n- internal/web/templates/layout.templ: base HTML shell (Tailwind CDN, HTMX CDN)\n- internal/web/templates/dashboard.templ: loop status panel\n- internal/handlers/pages.go: page handler reading from db\n- Shows: running/stopped, iteration count, current phase, current task, last update\n\n## Implementation Notes\n- Templ components compiled to Go code\n- Layout includes Tailwind CDN and HTMX CDN script tags\n- Status panel uses Tailwind utility classes for styling\n- Green/red indicator for running/stopped state\n- Reference: ~/code/observability/internal/web/templates/\n\n## Test Specifications\n- TestDashboardHandler_Returns200\n- TestDashboardHandler_RendersLoopStatus\n- TestLayoutTempl_IncludesCDNLinks\n\n## Manual Verification\n- go build -o server ./cmd/server && ./server\n- Open http://localhost:4000 in browser\n- Verify status panel renders with placeholder data"}
{"id":"demo-001.2","title":"Iteration history timeline","issue_type":"feature","status":"open","priority":2,"parent":"demo-001","labels":["history"],"description":"Display iteration history as a visual timeline with cards.\n\n## User Stories\n- As a developer, I can see past iterations so I can review what the loop accomplished\n- As a developer, I can see verdict badges so I can quickly identify successes and failures\n\n## Acceptance Criteria\n- [ ] History.jsonl data ingested into SQLite iterations table\n- [ ] Timeline page shows iteration cards with task ID, title, verdict, duration, commit hash\n- [ ] Color coding: green=completed, yellow=retry, red=failed\n- [ ] Commit hashes are clickable links\n\n## Technical Notes\n- Idempotent ingestion (skip already-imported iterations)\n- Cards sorted by iteration number descending (newest first)"}
{"id":"demo-001.2.1","title":"Ingest history.jsonl into SQLite","issue_type":"task","status":"open","priority":2,"parent":"demo-001.2","depends_on":["demo-001.1.2"],"labels":["data-pipeline","blocked"],"description":"Ingest loop history data from history.jsonl into SQLite.\n\n## Requirements\n- internal/handlers/api.go: POST /ingest/history endpoint\n- Reads history.jsonl, parses each line, stores in iterations table\n- iterations table: iteration, task_id, task_title, outcome, verdict, duration_seconds, action_count, commit_hash, intent, recorded_at\n- Idempotent: skip already-ingested iterations (by iteration number + recorded_at)\n\n## Implementation Notes\n- Accept multipart file upload or JSON body with file path\n- Parse each line as JSON, validate required fields\n- Batch insert with transaction for performance\n- Add iterations table migration to db.go\n\n## Test Specifications\n- TestIngestHistory_StoresIterations\n- TestIngestHistory_Idempotent\n- TestIngestHistory_InvalidJSON\n- TestGetIterations_ReturnsInOrder\n\n## Manual Verification\n- curl -X POST localhost:4000/ingest/history -d '{\"path\":\"/tmp/line-loop-test/history.jsonl\"}'\n- Verify data in SQLite: sqlite3 dashboard.db 'SELECT * FROM iterations'"}
{"id":"demo-001.2.2","title":"Timeline component with iteration cards","issue_type":"task","status":"open","priority":2,"parent":"demo-001.2","depends_on":["demo-001.2.1"],"labels":["frontend","blocked"],"description":"Render iteration history as a visual timeline with cards.\n\n## Requirements\n- GET /history renders timeline page\n- internal/web/templates/timeline.templ: iteration cards\n- Each card shows: task ID, title, verdict badge, duration, commit hash (linked), action count\n- Color coding: green=completed, yellow=retry, red=failed\n- Cards sorted by iteration number descending\n\n## Implementation Notes\n- Templ component for individual iteration card\n- Verdict badge uses Tailwind color classes (green-500, yellow-500, red-500)\n- Commit hash links to git repository (configurable base URL)\n- Duration formatted as human-readable (e.g. \"2m 30s\")\n- Reference: ~/code/observability/internal/web/templates/\n\n## Test Specifications\n- TestHistoryHandler_Returns200\n- TestHistoryHandler_RendersIterations\n- TestIterationCard_VerdictColors\n\n## Manual Verification\n- Ingest sample history data, then open http://localhost:4000/history\n- Verify cards render with correct colors and links"}
{"id":"demo-001.3","title":"Hook event receiver","issue_type":"feature","status":"open","priority":2,"parent":"demo-001","labels":["hooks","events"],"description":"Receive and display Claude Code hook events.\n\n## User Stories\n- As a developer, I can send hook events to the dashboard so I can see what Claude Code is doing\n- As a developer, I can filter events by type so I can focus on specific activities\n\n## Acceptance Criteria\n- [ ] POST /events endpoint accepts JSON hook event payload and returns 201\n- [ ] Events stored in SQLite events table\n- [ ] Event feed page with type filtering via HTMX (no full page reload)\n- [ ] Event type badges for visual distinction\n\n## Technical Notes\n- Validates required fields (event_type, payload)\n- HTMX-based filtering for smooth UX"}
{"id":"demo-001.3.1","title":"POST /events endpoint for hook data","issue_type":"task","status":"open","priority":2,"parent":"demo-001.3","depends_on":["demo-001.1.2"],"labels":["api","blocked"],"description":"Create the API endpoint for receiving hook event data.\n\n## Requirements\n- POST /events accepts JSON hook event payload\n- Stores in events table via db.InsertEvent\n- Returns 201 with event ID in response body\n- Validates required fields (event_type, payload)\n- Returns 400 with error message for invalid payloads\n\n## Implementation Notes\n- JSON request body: {\"event_type\": \"tool_use\", \"source\": \"claude-code\", \"payload\": {...}}\n- Response: {\"id\": 123, \"status\": \"created\"}\n- Use json.Decoder for request parsing\n- Reference: ~/code/observability/internal/handlers/api.go\n\n## Test Specifications\n- TestPostEvents_Returns201\n- TestPostEvents_StoresEvent\n- TestPostEvents_ValidatesRequiredFields\n- TestPostEvents_Returns400ForInvalid\n\n## Manual Verification\n- curl -X POST localhost:4000/events -H 'Content-Type: application/json' -d '{\"event_type\":\"tool_use\",\"source\":\"claude-code\",\"payload\":{\"tool\":\"Read\"}}'\n- Verify 201 response with event ID"}
{"id":"demo-001.3.2","title":"Event feed with type filtering","issue_type":"task","status":"open","priority":2,"parent":"demo-001.3","depends_on":["demo-001.3.1"],"labels":["frontend","blocked"],"description":"Render event feed page with HTMX-based type filtering.\n\n## Requirements\n- GET /events page with filterable event list\n- Filter by event_type dropdown\n- internal/web/templates/events.templ: event feed with type badges\n- HTMX-based filtering (no full page reload)\n- GET /events?type=tool_use returns filtered partial HTML\n\n## Implementation Notes\n- Dropdown triggers hx-get with type query parameter\n- Server renders partial HTML for HTMX swap\n- Event type badges with distinct colors per type\n- Newest events first, paginated (20 per page)\n- Reference: ~/code/observability/internal/web/templates/\n\n## Test Specifications\n- TestEventsHandler_Returns200\n- TestEventsHandler_FiltersByType\n- TestEventsHandler_ReturnsPartialForHTMX\n\n## Manual Verification\n- Post several events with different types\n- Open http://localhost:4000/events\n- Select filter dropdown, verify list updates without page reload"}
{"id":"demo-001.4","title":"Live updates via WebSocket","issue_type":"feature","status":"open","priority":2,"parent":"demo-001","labels":["realtime","websocket"],"description":"Push live updates to connected dashboard clients.\n\n## User Stories\n- As a developer, I can see dashboard updates in real time so I don't need to manually refresh\n- As a developer, I can see new events and status changes appear automatically\n\n## Acceptance Criteria\n- [ ] WebSocket hub manages connected clients with register/unregister/broadcast\n- [ ] New events broadcast JSON to all connected WebSocket clients\n- [ ] Dashboard auto-updates status panel and timeline via HTMX SSE\n- [ ] No polling required for updates\n\n## Technical Notes\n- Broadcast-only hub (no client-to-server messaging)\n- HTMX EventSource for HTML fragment streaming\n- Gorilla WebSocket library"}
{"id":"demo-001.4.1","title":"WebSocket hub and client management","issue_type":"task","status":"open","priority":2,"parent":"demo-001.4","depends_on":["demo-001.1.3"],"labels":["realtime","blocked"],"description":"Implement WebSocket broadcast hub for live updates.\n\n## Requirements\n- internal/ws/hub.go: broadcast-only WebSocket hub\n- GET /ws endpoint upgrades to WebSocket connection\n- Hub.Run() goroutine manages register/unregister/broadcast channels\n- On new event: broadcast JSON message to all connected clients\n- Graceful client disconnect handling\n\n## Implementation Notes\n- Hub struct with clients map, register/unregister/broadcast channels\n- Client struct with hub reference, conn, and send channel\n- WritePump and ReadPump goroutines per client\n- Use gorilla/websocket for WebSocket upgrade\n- Reference: ~/code/observability/internal/ws/\n\n## Test Specifications\n- TestHub_RegisterClient\n- TestHub_UnregisterClient\n- TestHub_BroadcastMessage\n- TestHub_ConcurrentClients\n\n## Manual Verification\n- Start server, open browser console\n- Connect: new WebSocket('ws://localhost:4000/ws')\n- Post an event via curl, verify message received in console"}
{"id":"demo-001.4.2","title":"HTMX streaming for real-time updates","issue_type":"task","status":"open","priority":2,"parent":"demo-001.4","depends_on":["demo-001.4.1"],"labels":["frontend","realtime","blocked"],"description":"Add HTMX-based streaming for automatic dashboard updates.\n\n## Requirements\n- GET /stream endpoint for HTMX EventSource (SSE)\n- On new event/status change: push HTML fragment via SSE\n- Dashboard auto-updates without polling\n- Status panel refreshes on loop status change\n- Timeline appends new iteration cards\n- Event feed appends new events\n\n## Implementation Notes\n- SSE endpoint sends text/event-stream content type\n- Each event contains rendered Templ HTML fragment\n- HTMX hx-ext=\"sse\" and sse-connect attributes on dashboard elements\n- Different event types for status, iteration, and hook events\n- Reference: HTMX SSE extension documentation\n\n## Test Specifications\n- TestStreamHandler_ReturnsSSE\n- TestStreamHandler_SendsHTMLFragments\n- TestDashboard_SSEConnectionAttributes\n\n## Manual Verification\n- Open dashboard in browser\n- Post events via curl in another terminal\n- Verify dashboard updates without manual refresh"}
{"id":"demo-100","title":"Retrospective & Parking Lot","issue_type":"epic","status":"open","priority":4,"labels":["parking-lot","retrospective"],"description":"Collection of ideas and improvements to consider later.\n\nItems here are NOT ready for immediate work. They represent:\n- Future enhancements beyond MVP\n- Ideas that need more research\n- Nice-to-haves that aren't blocking anything\n\n## How This Works\nTasks filed under this epic (with priority 4) are automatically filtered out of bd ready results. They can still be explicitly selected via /line:cook <task-id> if you want to work on them."}
{"id":"demo-100.1","title":"Add metrics charts and performance graphs","issue_type":"task","status":"open","priority":4,"parent":"demo-100","labels":["future","enhancement","research"],"description":"Add visual charts for loop performance metrics.\n\n## Research Topics\n- Chart.js vs D3.js vs lightweight alternatives\n- Metrics to track: iteration duration over time, action count trends, success rate\n- Time-series data aggregation in SQLite\n\n## Potential Features\n- Line chart: iteration duration over time\n- Bar chart: actions per iteration\n- Pie chart: verdict distribution (completed/retry/failed)\n- Sparklines in iteration cards\n\n## Why This is Parked\nCharts add significant complexity and are not needed for core dashboard functionality. The textual data in timeline cards provides sufficient information for MVP.\n\n## When to Revisit\n- After MVP is complete and validated\n- If users need trend analysis\n- When there's enough historical data to make charts meaningful"}
